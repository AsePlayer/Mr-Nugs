using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;

public class Pathfinder : MonoBehaviour
{
    /****************************************
     *             WHEN TESTING:
     *      green line = safe path
     *      yellow line = potential path
     *      blue line = no hitbox collision
     *      red line = hitbox collision
     * *************************************/

    // objects
    private Camera cam;                                    // the main camera. Used for finding path to clicked spot.
    [SerializeField] BoxCollider2D envBox;                 // the unit's box collider. Used to find values for colliderOffsets[]
    [SerializeField] Rigidbody2D rb;                       // the unit's rigidbody. Used for moving character along the path

    // testing
    [SerializeField] bool testing;                         // if true, lets you click on a spot and draws a path in editor view
    [SerializeField] float waitSeconds = 0.1f;             // speed of drawing the testing path

    // calculation
    [SerializeField] float moveSpeed = 5;                  // the speed that the character will follow a path
    [SerializeField] float granularity;                    // the space between each node (high = blocky + fast, low = accurate + slow)
    [SerializeField] const float pointRadiusRatio = 0.75f; // constant for checking if a newly generated node would be too close to another previous node (granularity * pointRadiusRatio)
                                                           // 0.38f = halfway, 0.57f = 75%, 0.75f = slightly shy of touching next checked spot
    private ContactFilter2D noTriggers;                    // filter that ignores collision with hitboxes set to isTrigger;

    // other
    private readonly float[] angleMods = { 0, Mathf.PI / 4, -Mathf.PI / 4, Mathf.PI / 2, -Mathf.PI / 2, 3 * Mathf.PI / 4, -3 * Mathf.PI / 4, Mathf.PI }; // order of applied rotations to a node (rad)
    private Vector2[] colliderOffsets;                     // corner coordinates of the unit's box collider. Used for detecting obstacles.
    private bool working = false;                          // false if new path can be calculated. True if action is currently blocking new path generation

    public struct node                    // A node marks each 'step' of the path generated by the script.
    {
        public Vector2 position;          // The coordinate of the node
        public int rotationIndex;         // How many times this node has been rotated (for seeing if all possible directions have been checked)

        public node(Vector2 pos, int rot)
        {
            this.position = pos;
            this.rotationIndex = rot;
        }
    }

    // Start is called before the first frame update
    void Start()
    {
        noTriggers.useTriggers = false;
        cam = Camera.main;
        colliderOffsets = new Vector2[] { new Vector2(-envBox.size.x/2 + envBox.offset.x, envBox.size.y/2 + envBox.offset.y)*gameObject.transform.localScale, // top left corner
            new Vector2(envBox.size.x/2 + envBox.offset.x, envBox.size.y/2 + envBox.offset.y)*gameObject.transform.localScale,                                // top right corner
            new Vector2(envBox.size.x/2 + envBox.offset.x, -envBox.size.y/2 + envBox.offset.y)*gameObject.transform.localScale,                               // bottom right corner
            new Vector2(-envBox.size.x/2 + envBox.offset.x, -envBox.size.y/2 + envBox.offset.y)*gameObject.transform.localScale                               // bottom left corner
        };
    }

    // Update is called once per frame
    void Update()
    {
        if (testing && !working)
        {
            if (Input.GetMouseButtonDown(0))
            {
                Ray ray = cam.ScreenPointToRay(Input.mousePosition);
                StartCoroutine(drawPath(new Vector2(ray.origin.x, ray.origin.y), true));
            }
        }
    }

    private List<Vector2> toVector(List<node> path)
    {
        List<Vector2> newPath = new List<Vector2>();
        foreach (node n in path)
        {
            newPath.Add(n.position);
        }
        return newPath;
    }

    // Moves character along given path
    public IEnumerator moveAlongPath(List<Vector2> path)
    {
        int pathIndex = 0;

        while (pathIndex < path.Count)
        {
            // step = moveSpeed * Time.deltaTime;
            // transform.position = Vector2.MoveTowards(transform.position, path[pathIndex].position, step);

            rb.velocity = (path[pathIndex] - (Vector2)transform.position).normalized*moveSpeed;

            if ((path[pathIndex] - rb.position).magnitude < 0.1)//0.05)                                         // character is close to goal
            {
                rb.position = path[pathIndex];                                                            // put character at goal
                pathIndex++;                                                                              // go to next goal
                if (pathIndex < path.Count)
                {
                    rb.velocity = (path[pathIndex] - (Vector2)transform.position).normalized * moveSpeed;
                }
                else
                {
                    rb.velocity = Vector2.zero;
                    rb.position = path.Last();
                }
            }
            yield return null;
        }
        
        working = false;
    }

    // Checks for obstacles in the way of a path using unit's box collider
    private bool obstacleInWay(Vector2 start, Vector2 end, bool debugLines)
    {
        if (!canStandHere(end, debugLines))
        {
            return true;
        }
        bool oiw = false;
        foreach (Vector2 offset in colliderOffsets)                               // Uses each corner of box collider
        {
            RaycastHit2D[] results = new RaycastHit2D[20];                        // Linecast collisions are stored here
            int ray = Physics2D.Linecast(end + offset, start + offset, noTriggers, results);  // Draws a line from where corner is and will be
            if (ray == 0 || results[0].collider.gameObject == gameObject)         // If no collision, carry on
            {
                if (debugLines)
                    Debug.DrawLine(end + offset, start + offset, Color.blue, waitSeconds);
            }
            else                                                                  // Else return true
            {
                if (debugLines)                                                   // Check each corner even if there was a collision when in testing mode
                {
                    Debug.DrawLine(end + offset, start + offset, Color.red, waitSeconds);
                    oiw = true;
                }
                else return true;
            }
        }
        return oiw;                                                               // No obstacle in the way for every corner!

        
    }

    // Draws the unit's collision box at the desired destination to see if you can stand there
    bool canStandHere(Vector2 dest, bool debugLines)
    {
        bool oiw = true;
        for (int i = 0; i < 4; i++)                                               // Uses each corner of box collider
        {
            RaycastHit2D[] results = new RaycastHit2D[20];                        // Linecast collisions are stored here
            int ray = Physics2D.Linecast(dest + colliderOffsets[i], dest + colliderOffsets[(i+1)%4], noTriggers, results);  // Draws a line from corner to corner
            if (ray == 0 || results[0].collider.gameObject == gameObject)         // If no collision, carry on
            {
                if (debugLines)
                    Debug.DrawLine(dest + colliderOffsets[i], dest + colliderOffsets[(i + 1) % 4], Color.blue, waitSeconds);
            }
            else                                                                  // Else return true
            {
                if (debugLines)                                                   // Check each corner even if there was a collision when in testing mode
                {
                    Debug.DrawLine(dest + colliderOffsets[i], dest + colliderOffsets[(i + 1) % 4], Color.red, waitSeconds);
                    oiw = false;
                }
                else return false;
            }
        }
        return oiw;

    }

    // Cuts unnecessary nodes out of a path
    public List<Vector2> refinePath(List<Vector2> path)
    {
        List<Vector2> refinedPath = new List<Vector2>();            // All necessary nodes will be added to this list and returned.

        if (path.Count > 0)                                         // An empty list is already optimized.
        {
            Vector2 currentNode = path[^1];
            int checkIndex = 0;

            refinedPath.Add(currentNode);                           // List will always have destination node

            while (currentNode != path[0])                          // Loop ends when all nodes have been checked. The first node of the path will be last checked.
            {
                if (!obstacleInWay(path[checkIndex], currentNode, false))  // If no obstacles between nodes,
                {
                    refinedPath.Add(path[checkIndex]);              // skip all nodes in between them
                    currentNode = path[checkIndex];                 // start refining from end node
                    checkIndex = 0;                                 // search for nodes starting at the beginning again
                }
                else checkIndex++;                                  // Else check the next farthest one
            }
        }

        if (testing)
        {
            for (int i = 0; i < refinedPath.Count - 1; i++)
            {
                Debug.DrawLine(refinedPath[i], refinedPath[i + 1], Color.green, 3);
                foreach (Vector2 offset in colliderOffsets)
                {
                    Debug.DrawLine(refinedPath[i] + offset, refinedPath[i + 1] + offset, Color.blue, 3);
                }
            }
        }

        refinedPath.Reverse();
        return refinedPath;
    }

    // returns path from gameobject to given destination. if there is no path, returns an empty list.
    public List<Vector2> findPathTo(Vector2 destination)
    {
        working = true;
        if (!canStandHere(destination, testing))        // Check if you can stand on desired spot
        {
            working = false;
            return new List<Vector2>();                 // Can't find a path to an impossible location!
        }
        Vector2 currentPos = gameObject.transform.position;

        List<node> allTriedNodes = new List<node>();    // will keep track of areas visited
        List<node> path = new List<node>();             // will keep track of path being generated
        node first = new node(currentPos, 0);
        path.Add(first);                                // first node is character current position
        allTriedNodes.Add(first);

        while (path.Count > 0)
        {
            while (path.Last().rotationIndex >= 8)                                                                    // if tried all directions for this node,
            {
                path.RemoveAt(path.Count - 1);
                if (path.Count <= 0)
                    return toVector(path);
                path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);                                   // rotate the previous node
            }

            if (Vector2.Distance(path.Last().position, destination) <= granularity && path.Last().rotationIndex == 0) // if destination is 1 step away and not tried yet,
            {
                if (!obstacleInWay(path.Last().position, destination, false))                                         // if no obstacles in the way, path done!
                {
                    path.Add(new node(destination, 0));
                    break;
                }
                else                                                                                                  // else proceed as normal, starting from the next rotation
                {
                    path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);
                }
            }

            Vector2 newDestination = findDestination(path.Last().position, destination, angleMods[path.Last().rotationIndex]); // next spot to check

            // check for if new point is too close to a previously checked point
            bool tooClose = false;
            foreach (node check in allTriedNodes)                                                                     // go through all previously visited spots
            {
                if ((newDestination - check.position).magnitude <= granularity * pointRadiusRatio)                    // if too close to a previously visited spot,
                {
                    tooClose = true;                                                                                  // let the next 'if' know that this one is too close!
                    path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);                               // rotate the node
                    break;
                }
            }

            if (tooClose)
                continue;

            if (!obstacleInWay(path.Last().position, newDestination, false))                                          // if no obstacles in way and area not already checked,
            {
                node newPath = new node(newDestination, 0);                                                           // add that spot to the path!
                path.Add(newPath);
                allTriedNodes.Add(newPath);
            }

            else
            {
                path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);
            }
        }

        List<Vector2> refined = refinePath(toVector(path));
        working = false;

        return refined;
    }

    // For testing only
    public IEnumerator drawPath(Vector2 destination, bool follow)
    {
        working = true;
        if (!canStandHere(destination, testing))        // Check if you can stand on desired spot
        {
            working = false;
            yield break;                                // Can't find a path to an impossible location!
        }
        Vector2 currentPos = gameObject.transform.position;

        List<node> allTriedNodes = new List<node>();    // will keep track of areas visited
        List<node> path = new List<node>();             // will keep track of path being generated
        node first = new node(currentPos, 0);
        path.Add(first);                                // first node is character current position
        allTriedNodes.Add(first);
        Debug.Log("Starting path generation from " + currentPos + " to " + destination);

        int counter = 0;
        while (path.Count > 0 && counter < 100)
        {
            while (path.Last().rotationIndex >= 8)                                                                    // if tried all directions for this node,
            {
                path.RemoveAt(path.Count - 1);                                                                        // take current node out of the path
                Debug.Log("Node removed");
                printPath();
                drawlines();
                if (path.Count <= 0)
                    yield break;
                path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);                                   // rotate the previous node
                
                yield return new WaitForSeconds(waitSeconds);
            }

            if (Vector2.Distance(path.Last().position, destination) <= granularity && path.Last().rotationIndex == 0) // if destination is 1 step away and not tried yet,
            {
                if (!obstacleInWay(path.Last().position, destination, testing))                                       // if no obstacles in the way, path done!
                {
                    path.Add(new node(destination, 0));
                    Debug.Log("Path Finished");
                    printPath();
                    drawlines();
                    break;
                }
                else                                                                                                  // else proceed as normal, starting from the next rotation
                {
                    Debug.Log("Obstacle in the way of destination " + path.Last().position + path.Last().rotationIndex);
                    path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);
                    printPath();
                    drawlines();
                    yield return new WaitForSeconds(waitSeconds);
                }
            }

            Vector2 newDestination = findDestination(path.Last().position, destination, angleMods[path.Last().rotationIndex]); // next spot to check

            // check for if new point is too close to a previously checked point
            bool tooClose = false;
            foreach (node check in allTriedNodes)                                                                     // go through all previously visited spots
            {
                if ((newDestination - check.position).magnitude <= granularity * pointRadiusRatio)                    // if too close to a previously visited spot,
                {
                    tooClose = true;                                                                                  // let the next 'if' know that this one is too close!
                    path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);                               // rotate the node
                    Debug.Log("Node was too close");
                    printPath();
                    drawlines();
                    yield return new WaitForSeconds(waitSeconds);
                    break;
                }
            }

            if (tooClose)                                                                                             // If node is too close, go to the next rotation/node
                continue;

            if (!obstacleInWay(path.Last().position, newDestination, testing))                                        // if no obstacles in way and area not already checked,
            {
                node newPath = new node(newDestination, 0);                                                           // add that spot to the path!
                path.Add(newPath);
                allTriedNodes.Add(newPath);
                Debug.Log("New node added to path: " + newPath.position.x + ", " + newPath.position.y);
                printPath();
                drawlines();
                yield return new WaitForSeconds(waitSeconds);
            }

            else
            {
                Debug.Log("Obstacle in the way of destination " + path.Last().position + path.Last().rotationIndex);
                path[^1] = new node(path[^1].position, path[^1].rotationIndex + 1);                                   // else rotate the node
                printPath();
                drawlines();
                yield return new WaitForSeconds(waitSeconds);
            }

            Debug.Log("End of loop");
            printPath();
            drawlines();
            yield return new WaitForSeconds(waitSeconds);
        }

        Debug.Log("Path is " + path.Count + " nodes long.");
        yield return new WaitForSeconds(waitSeconds);

        if (counter == 99)
            Debug.Log("100 iterations of loop");
        counter++;

        List<Vector2> refined = refinePath(toVector(path));
        if (follow) StartCoroutine(moveAlongPath(refined));
        else working = false;

        void printPath()
        {
            string s = "";
            foreach (node n in path)
            {
                s += n.position + ", " + n.rotationIndex + " - ";
            }
            Debug.Log("Current path: " + s);
        }

        void drawlines()
        {
            for (int i = 0; i < path.Count - 1; i++)
            {
                Debug.DrawLine(path[i].position, path[i + 1].position, Color.green, waitSeconds);
            }
            if (path.Count > 0 && path.Last().rotationIndex < 8)
                Debug.DrawLine(path.Last().position, findDestination(path.Last().position, destination, angleMods[path.Last().rotationIndex]), Color.yellow, waitSeconds);
        }
    }

    // returns a vector of 'granularity' distance in the desired direction
    private Vector2 findDestination(Vector2 start, Vector2 destination, float rotation)
    {
        Vector2 direction = destination - start;
        Vector2 directionRotated = new Vector2(direction.x * Mathf.Cos(rotation) - direction.y * Mathf.Sin(rotation), direction.x * Mathf.Sin(rotation) + direction.y * Mathf.Cos(rotation));
        Vector2 newDest = directionRotated.normalized * granularity + start;

        // Debug.Log("From: " + start + " To: " + destination + " Result: " + newDest);
        return newDest;
    }
}
